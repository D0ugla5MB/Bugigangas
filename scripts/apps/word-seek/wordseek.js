/*
GRID System

Matrix of SQUAREs (spans).
Each SQUARE has a letter and a position (coordinates x, y).
VECTORs (words) are sequences of SQUAREs forming a straight-line word.
GRID must be larger than any VECTOR.

Interaction Mechanics

Selection Methods:

Click-to-Click: Start selection with the first click, end with the second, with dynamic CSS updates on hover.
Drag Selection: Mousedown to start selection and mouseup to end, with dynamic CSS updates on hover.
Manual Click: Click on each letter/square individually.
Feedback & Validation:

Use a buffer to store selected squares during selection (one direction storage).
Validate that selected squares form a valid, straight-line VECTOR.
Validate VECTORs against a word list upon selection completion.
Mark found words on the grid.
Apply debouncing to selection methods.
Define selection break points without affecting validation logic.


## Identifier System

    - chosen method: ** Index-Based **.
        Fast direction checks using arithmetic; O(1) in best case and O(n) in average/worst case.

        Index-Based Approach
        Best Case (Invalid Direction):
            Time: O(1)
                The direction check (dx, dy) immediately determines the selection is invalid (e.g., non-straight line).
                Example: Horizontal selection with a vertical component (dx ≠ 0 and dy ≠ 0).

        Average/Worst Case (Valid Direction):
            Time: O(n)
                After validating direction, the path is generated by iterating n steps (e.g., a diagonal of length n).
                Example: A valid horizontal word spanning k letters requires k steps to generate indices.

    Graph-Based Approach
        Best Case (Immediate Edge Failure):
            Time: O(1)
            The first edge check fails (e.g., no edge exists in the required direction).
            Example: Start node lacks a "right" edge for a horizontal selection.

        Average/Worst Case (Full Traversal):
            Time: O(n)
                The path is valid and requires traversing n edges.
                Example: A valid vertical word spanning k letters requires k edge lookups.

        Worst-Case Edge Checks:
            Even for invalid paths, traversal stops at the first missing edge (e.g., after k < n steps).
            Example: A diagonal path breaks at step k=3 due to a missing edge.

    Key Differences
        Index-Based:
            Strengths: Minimal overhead for direction checks (arithmetic).
            Weakness: No precomputed adjacency data (edges) for non-linear extensions.

        Graph-Based:
            Strengths: Explicit edge storage enables dynamic grids (e.g., obstacles).
            Weakness: Higher constant factors due to edge lookups and object dereferencing.


            ### ** GRID Positioning **:
        - Can apply graphs connections; each node would be a letter; the edges would be the link between the letters.
        - For the selected words,save the pair (first letter, last letter) = [(x1, y1), (x2, y2)].
        - Must guarentee a linear connection
        - A letter pointer always connects with the opposed letter pointer. LxR, RxL, UxD, DxU, ...

    ### ** Grid Position Calculation **
Use a top-left coordinate system.
Treat the grid as a single array

        Base Equation:  arr_pos = (arr_len / sub_arr_len) * sub_arr_n + sub_arr_index  

        Horizontal Movements:  
            Move Left (←): arr_pos_left = arr_pos - 1 (if sub_arr_index > 0)  
            Move Right (→): arr_pos_right = arr_pos + 1 (if sub_arr_index < sub_arr_len - 1)  

        Vertical Movements:  
            Move Up (↑): arr_pos_up = arr_pos - (arr_len / sub_arr_len) (if sub_arr_n >= (arr_len / sub_arr_len))  
            Move Down (↓): arr_pos_down = arr_pos + (arr_len / sub_arr_len) (if sub_arr_n < arr_len / sub_arr_len - 1)  

        Diagonal Movements:  
            Move Top-Left (↖): arr_pos_topLeft = arr_pos - (arr_len / sub_arr_len) - 1  
            Move Top-Right (↗): arr_pos_topRight = arr_pos - (arr_len / sub_arr_len) + 1  
            Move Bottom-Left (↙): arr_pos_bottomLeft = arr_pos + (arr_len / sub_arr_len) - 1  
            Move Bottom-Right (↘): arr_pos_bottomRight = arr_pos + (arr_len / sub_arr_len) + 1  

        Simplified logic:
                Left (←):
                Non-Simplified:  l  = -(n - 1)
                Fully Simplified: l  = -n + 1

                Right (→):
                Non-Simplified:  r  = n - 1
                Fully Simplified: r  = n - 1

                Up (↑):
                Non-Simplified:  u  = -(sub_arr_len * (n - 1))
                Fully Simplified: u  = -sub_arr_len * n + sub_arr_len

                Down (↓):
                Non-Simplified:  d  = sub_arr_len * (n - 1)
                Fully Simplified: d  = sub_arr_len * n - sub_arr_len

                Top-Left (↖):
                Non-Simplified:  tl = -(sub_arr_len + 1) * (n - 1)
                Fully Simplified: tl = -sub_arr_len * n + sub_arr_len - n + 1

                Top-Right (↗):
                Non-Simplified:  tr = -(sub_arr_len - 1) * (n - 1)
                Fully Simplified: tr = -sub_arr_len * n + sub_arr_len + n - 1

                Bottom-Left (↙):
                Non-Simplified:  bl = (sub_arr_len - 1) * (n - 1)
                Fully Simplified: bl = sub_arr_len * n - sub_arr_len - n + 1

                Bottom-Right (↘):
                Non-Simplified:  br = (sub_arr_len + 1) * (n - 1)
                Fully Simplified: br = sub_arr_len * n - sub_arr_len + n - 1

## Create previously a list containing the possible number of the different arrow eq can be generated with some matrix size.

if matrix is a square matrix, then
    col_n = row_n = matrix_side_size, then col_n + row_n = 2 * matrix_side_size

    since diag_n and anti_diag_n are opposite, diag_n = anti_diag_n, so diag_n + anti_diag_n = 2 * diag_m, but
    since each matrix is a quadrilateral, the arrow cross only the vertices, and if the word_s > 1, then those arrows are not necessary, then, since any quadrilateral has 4v, diag_n + anti_diag_n = 2 * diag_m - 4, finally

arrows_n = matrix_side_size * 2 + 2 * diag_m - 4
' = 2* (matrix_side_size + diag_m) - 4
' = 2 * (matrix_side_size + diag_m - 2)


## Vector creation
    After had selected some direction, 
    get the first and last letters' positions.    
    generate an arrow equation using the first and last letters' positions,
    if this equation exists, make another equation.

## Word Placement on Grid
Before to place the words' letters, randonly place a letter at each square.
to place some word:
    Select a random span/index/square.
    Randomly select a direction.
    Check the word size.
    Found out some space, exclude that vector from the possible vectors.    



## Word Sources
    - API: [Datamuse](https://www.datamuse.com/api/)
    - Group words by ** relation / category **.

Game Modes (Should NOT Affect Word Placement & Checking)

Classic: Find all words.
Optional Features:
Timer system.
Score system.
Hints.   
  
  
  
        
*/